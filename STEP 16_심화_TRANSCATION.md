# 트랜잭션 분석 시나리오

## 트랜잭션 분리시 서비스 요청 방식
### 내부적(모듈)을 분리의 경우
  #### 이벤트 이미터 활용
  - 이벤트 기반 통신으로 호출(비동기적 처리)
  - 의존성을 줄일 수 있음
  - 에러의 위치를 찾기 어려움
  - 각 이벤트에 대한 성공 여부를 확인 필요
  - 보상 트랜잭션 구현의 어려움
#
### 외부적(서버) 분리의 경우  
  #### HTTP 요청
  - 표준적인 방식(이해하기 쉽다, 접근성이 좋다)
  - 동기적 방식이기 때문에 응답 지연의 존재 가능성.
  - 네트워크의 상태에 대한 영향도가 높음.
  - 호출이 많을 경우 부하가 큼.
  #### 데이터베이스 기반 이벤트 전달
  - 발행 서비스가 이벤트를 저장하고, 구독 서비스가 주기적인 조회를 통해 확인 후 처리하는 방식
  - 주기적인 조회를 통한 성능 및 과부하 이슈 발생 가능
  #### 메시지 브로커 활용(kafka 등)
  - 비동기 처리(서비스 간 결합도가 높지 않음, 최종적 일관성 보장, 실시간성은 떨어짐)
  - 메시지에 대한 저장공간(브로커)가 있기 때문에 서비스 종료에 대한 리스크가 적다
  - 보다 높은 사용 난이도, 관리포인트 증가
  #### 웹소켓
  - 지속적인 양방향 실시간 통신 가능
  - 많은 양의 리소스 요구, 네트워크 상태에 대한 영향도가 높음.
----------------------
## 콘서트 예약 서비스에서 트랜잭션 분리 방안
### 트랜잭션 범위가 넓은 API
  #### 결재 API
  - 검증 : 임시예약(콘서트, 콘서트 일정, 콘서트 티켓), 유저 검증, 잔액 조회 및 비교
  - 데이터 수정 : 잔액 차감, 예약 확정, 예약 이력 기록
### 1. 검증과 수정을 도메인 기준으로 분리
  - 각각의 도메인에 맞게끔 검증 후 수정
  - 우선순위를 정하여 순차적으로 실행
  - 순차적으로 실행해야함으로 트랜잭션만 분리해서 관리 가능
  - 실행 도중 실패하는 경우(재시도 포함) 앞 순서의 수정내역을 롤백상태와 동일하게 만들 수 있는 작업 시행
### 2. 검증 / 수정으로 분리
- #### 검증
  - 검증의 경우 분리하지 않는것이 유리하다고 판단
  - 순차적으로 검증하여 데이터 조회 풀 자체를 줄이고
  - 우선순위를 둬서 실패 시 바로 예외를 던질 수 있도록 설계하는것이 유리.
- #### 수정
  - 모듈 분리시
    - 이벤트 이미터를 활용하여 해당 API요청
    - 이벤트 요청 시 결과를 알 수 없기 때문에 API 자체적인 재시도 로직 구현 필요
    - 최종적인 일관성을 확인할 수 있는 방안 모색(스케줄러를 통한 확인 등)
  - 서버 분리시
    - 구현과 관리포인트에 대한 난이도는 높지만 빠른 처리와 안정성을 어느정도 확보할 수 있는 kafka를 활용(To be Continued...)
### 1. 검증과 수정을 도메인별로 분리하는 방안 채택
  - 모듈을 분리하여 이벤트 이미터로 제어 시 해당 트랜잭션에 대한 최종 실패에 대한 구현이 어려
----------------------
## 테스트 중 삽질...
### STEP 15_INDEX 관련
- 1000만건의 데이터를 INSERT 시도 중 트랜잭션을 적절하게 완료시키지 않았을 때
- 2시에 잠들어 8시에 확인을 하였으나 750만 언저리에서 느려진 채 진행중이었습니다.
- 1만 건씩 나누어 트랜잭션 처리를 하였을 경우 천만건이 INSERT 되는데 대략 6분이 조금 안걸리는걸 확인할 수 있었습니다.
![인서트 결과 ](https://github.com/user-attachments/assets/b91d1de0-af2b-470c-bea7-4ca70b268da3)
- 인서트 스크립트 : https://github.com/durara021/hhplus-concert-ticketing/blob/branch/src/tests/k6test/concert/insert.concertTicket.spec.ts
- 현재의 트랜잭션 분리 이슈와 동일한 이슈는 아니었으나
- 트랜잭션을 잘게 쪼개지 않았을 경우에 발생할 수 있는 이슈에 대한 경각심이 확실하게 생기는 게기가 되었습니다!


